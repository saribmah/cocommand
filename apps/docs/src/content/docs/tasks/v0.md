---
title: v0 Implementation Tasks
---

# tasks/v0.md — Cocommand v0 Implementation Plan

> **v0 Goal:** Build a command-first desktop shell with a deterministic core (routing → planning → permissions → tool execution → workspace patch), a small set of built-ins (Clipboard, Notes, Calculator), and a Deno-based extension host, with event-stream observability.

---

## Milestone 0 — Repo scaffolding & module layout

### Tasks

* Create the core module layout in `crates/cocommand/src/` using `module.rs + module/`.
* Add a minimal “core runtime” struct (`Core`) that will be the stable integration point for Tauri.
* Define a shared `Result`/error type.

### Targets

* `crates/cocommand/src/lib.rs`
* `crates/cocommand/src/core.rs`
* `crates/cocommand/src/error.rs`
* Create folders:

    * `crates/cocommand/src/command/`
    * `crates/cocommand/src/routing/`
    * `crates/cocommand/src/planner/`
    * `crates/cocommand/src/workspace/`
    * `crates/cocommand/src/permissions/`
    * `crates/cocommand/src/tools/`
    * `crates/cocommand/src/events/`
    * `crates/cocommand/src/extensions/`
    * `crates/cocommand/src/builtins/`

### Acceptance Criteria

* `cargo test -p cocommand` runs with a placeholder test.
* Core crate compiles without any Tauri dependency.

### Definition of Done

* Module files exist and are wired through `lib.rs`.
* `Core::new()` compiles and returns a valid instance.

### Test Checklist

* `cargo check -p cocommand`
* `cargo test -p cocommand`

---

## Milestone 1 — Workspace v0 (schema + invariants + kernel tools)

### Tasks

* Implement Workspace state structs matching your Workspace Schema v0.
* Implement invariant checks (focus validity, mounted tools referencing open instances, etc.).
* Implement Kernel Tools (as Rust functions) for:

    * `open_application`
    * `close_application`
    * `focus_application`
    * `mount_tools`
    * `unmount_tools`
* Implement atomic mutation application (`apply_patch` / transactional updates).

### Targets

* `crates/cocommand/src/workspace.rs`
* `crates/cocommand/src/workspace/state.rs`
* `crates/cocommand/src/workspace/invariants.rs`
* `crates/cocommand/src/workspace/kernel_tools.rs`
* `crates/cocommand/src/workspace/patch.rs`

### Acceptance Criteria

* Workspace can be created, serialized, deserialized.
* Kernel tools mutate workspace only through sanctioned functions.
* Invariant violations return structured errors.

### Definition of Done

* Workspace is the single source of truth for open instances, focus, mounts, context, policy, journal refs.
* All kernel tools are idempotent where specified.

### Test Checklist

* Unit tests for invariants:

    * focus points to open instance
    * mounted tools require active instance
* Unit tests for kernel tool behaviors:

    * open → instance added
    * focus → focus changes
    * close → instance removed and tools unmounted

---

## Milestone 2 — Events + Observability v0 (event stream + invocation logs)

### Tasks

* Define canonical event types:

    * `UserMessage`
    * `ToolCallProposed`
    * `ToolCallAuthorized` / `ToolCallDenied`
    * `ToolCallExecuted`
    * `ToolResultRecorded`
    * `WorkspacePatched`
    * `ErrorRaised`
* Implement an append-only event store (in-memory v0; file-backed optional).
* Implement tool invocation record with:

    * timing
    * status codes
    * redaction markers
    * workspace before/after hash
    * model/prompt provenance placeholders
* Implement checkpointing hooks (optional in v0).

### Targets

* `crates/cocommand/src/events.rs`
* `crates/cocommand/src/events/event.rs`
* `crates/cocommand/src/events/store.rs`
* `crates/cocommand/src/events/redaction.rs`
* `crates/cocommand/src/events/replay.rs`
* `crates/cocommand/src/tools/invocation.rs` (shared types)

### Acceptance Criteria

* Every tool call generates an invocation record and at least one event.
* Workspace patch events include before/after hashes.

### Definition of Done

* You can replay an event stream to rehydrate a workspace snapshot (even if limited to v0 events).

### Test Checklist

* Event store append/read order tests
* Replay tests: start with empty workspace → apply events → end state matches expected

---

## Milestone 3 — Tool system v0 (registry + schemas + execution pipeline)

### Tasks

* Define `Tool` abstraction:

    * `tool_id`
    * input/output JSON schema
    * risk level
    * handler function signature
* Implement `ToolRegistry` supporting:

    * kernel tools (always available)
    * mounted application tools (by instance)
* Implement execution pipeline skeleton:

    * validate args
    * permissions gate (stub until Milestone 4)
    * execute handler
    * record events/invocation
    * apply workspace patch (if kernel tool)

### Targets

* `crates/cocommand/src/tools.rs`
* `crates/cocommand/src/tools/registry.rs`
* `crates/cocommand/src/tools/schema.rs`
* `crates/cocommand/src/tools/executor.rs`

### Acceptance Criteria

* Can register tools and invoke them with JSON args.
* Schema validation errors are returned cleanly.
* Tool execution produces observability records.

### Definition of Done

* `Core::invoke_tool(tool_id, args)` exists and is used internally.

### Test Checklist

* Tool registry: register/lookup
* Schema validation: good args succeed, bad args fail
* Execution: tool call emits events + invocation record

---

## Milestone 4 — Permissions layer v0 (scopes + risk + enforcement)

### Tasks

* Define permission scopes and user decision store:

    * allow / ask / deny
* Implement risk levels: safe / confirm / destructive.
* Implement enforcement function:

    * given (app, capability/tool, args, context) → allow/deny/needs_confirm
* Integrate permission checks into tool executor.
* Implement “confirmation pending” workspace mode (state only; UI later).

### Targets

* `crates/cocommand/src/permissions.rs`
* `crates/cocommand/src/permissions/scopes.rs`
* `crates/cocommand/src/permissions/risk.rs`
* `crates/cocommand/src/permissions/store.rs`
* `crates/cocommand/src/permissions/enforcement.rs`

### Acceptance Criteria

* Destructive tools require explicit confirmation decision before execution.
* Permission-denied tools do not mutate workspace state and record denial events.

### Definition of Done

* Permission layer is authoritative and used by the executor for every tool call.

### Test Checklist

* Safe tool runs without confirmation
* Confirm tool sets “awaiting_confirmation” mode (or returns NeedsConfirm)
* Denied tool returns error + emits denial event

---

## Milestone 5 — Command parsing v0 (text → command + tags)

### Tasks

* Implement command parser:

    * raw text
    * extract `@app` tags (allowlist semantics)
    * normalize command text
* Define `CommandRequest` struct used by router/planner.

### Targets

* `crates/cocommand/src/command.rs`
* `crates/cocommand/src/command/parser.rs`
* `crates/cocommand/src/command/tagging.rs`
* `crates/cocommand/src/command/types.rs`

### Acceptance Criteria

* `@notes @calendar create a meeting…` extracts tags `[notes, calendar]` and strips them from command text.
* No tags → empty allowlist.

### Definition of Done

* Parser is deterministic and tested with edge cases (emails, @ in text, etc.).

### Test Checklist

* Tag extraction tests
* Command normalization tests

---

## Milestone 6 — Routing v0 (capability router)

### Tasks

* Define routing metadata for apps/capabilities:

    * keywords, examples
* Implement a simple v0 router:

    * lexical scoring over keywords/examples
    * workspace priors (pinned/recent/open/focused)
    * tag allowlist filter
* Output:

    * candidate capabilities/app IDs
    * confidence score

### Targets

* `crates/cocommand/src/routing.rs`
* `crates/cocommand/src/routing/metadata.rs`
* `crates/cocommand/src/routing/router.rs`
* `crates/cocommand/src/routing/scoring.rs`

### Acceptance Criteria

* Router returns bounded candidate list (e.g., <= 7 apps).
* Tags restrict candidates to tagged apps only.

### Definition of Done

* `Core::route(command_request)` exists and is used before planning.

### Test Checklist

* Router selects expected candidates for known commands
* Tag allowlist prevents non-tagged results

---

## Milestone 7 — Planning v0 (LLM planner interface + stubs)

### Tasks

* Define planner interface returning a **plan**:

    * list of tool calls (proposed)
    * optional user clarification questions
* Implement a stub planner (rule-based) for v0 end-to-end testing.
* Add LLM provider interface (OpenAI/Anthropic) behind a trait (optional for v0).
* Record planner provenance (model/prompt version fields in events).

### Targets

* `crates/cocommand/src/planner.rs`
* `crates/cocommand/src/planner/types.rs`
* `crates/cocommand/src/planner/stub.rs`
* `crates/cocommand/src/planner/providers/` (optional)

    * `openai.rs`, `anthropic.rs`

### Acceptance Criteria

* Given router candidates + command, planner returns tool calls.
* For ambiguous inputs, planner returns “needs_clarification”.

### Definition of Done

* Core can run without real LLM using stub planner.
* Planner output is structured and logged.

### Test Checklist

* Stub planner produces correct tool call sequence for sample commands

---

## Milestone 8 — Built-in apps v0 (Clipboard, Notes, Calculator)

### Tasks

* Implement built-in Application definitions:

    * app metadata
    * capabilities
    * tool implementations (handlers)
    * routing metadata
    * permission scopes and risk levels
* Implement at least:

    * Clipboard: list/latest
    * Notes: list/latest/create/update/delete (delete = destructive)
    * Calculator: eval/parse (safe)

### Targets

* `crates/cocommand/src/builtins.rs`
* `crates/cocommand/src/builtins/clipboard.rs`
* `crates/cocommand/src/builtins/notes.rs`
* `crates/cocommand/src/builtins/calculator.rs`

### Acceptance Criteria

* Commands can be routed → planned → executed end-to-end using built-ins.
* Notes delete requires confirmation per permissions.

### Definition of Done

* Built-ins register their tools into the tool registry and routing metadata into the router.

### Test Checklist

* End-to-end test harness (no UI): run command “show last note” and get preview payload
* Confirm flow: “delete last note” returns needs-confirm then executes after approval

---

## Milestone 9 — Follow-up mode + session TTL v0 (core behavior)

### Tasks

* Implement ephemeral follow-up context:

    * last result references
    * expires_at
    * turn limit
* Bias router during follow-up window.
* Add workspace mode changes (`idle` ↔ `follow_up_active`).

### Targets

* `crates/cocommand/src/core.rs` (session orchestration)
* `crates/cocommand/src/workspace/state.rs` (context additions)
* `crates/cocommand/src/routing/router.rs` (biasing)

### Acceptance Criteria

* After creating a calendar event (or stub), “make it 2:30” resolves against the last entity reference.
* After TTL expiry, same input no longer resolves and triggers clarification.

### Definition of Done

* Follow-up behavior is deterministic and bounded.

### Test Checklist

* Follow-up within TTL works
* Follow-up after TTL does not

---

## Milestone 10 — Extension host v0 (Deno) + RPC + sample extension

### Tasks

* Implement Deno extension host process:

    * load manifest
    * register tools
    * invoke tool handler
* Implement RPC protocol (stdio JSON-RPC recommended for v0).
* Implement Rust-side extension manager:

    * install/load/unload
    * tool catalog sync
    * invoke routing metadata ingestion
* Create one sample extension:

    * `my_app.create_ticket` with safe output

### Targets

* `crates/cocommand/src/extensions.rs`
* `crates/cocommand/src/extensions/manifest.rs`
* `crates/cocommand/src/extensions/rpc.rs`
* `crates/cocommand/src/extensions/lifecycle.rs`
* `apps/extension-host/` (new)

    * `main.ts`
    * `protocol.ts`
    * `loader.ts`
* `extensions/sample-my-app/` (new)

### Acceptance Criteria

* Rust core can invoke an extension tool and receive JSON result.
* Extension tools appear in routing candidates.

### Definition of Done

* End-to-end: command routes to extension tool → executes via Deno → logs events.

### Test Checklist

* Integration test with spawned Deno host
* Timeout test: host hangs → invocation times out cleanly

---

## Milestone 11 — Desktop shell integration (Tauri) v0

### Tasks

* Add Tauri invoke commands:

    * `submit_command`
    * `confirm_action`
    * `get_recent_actions`
    * `get_workspace_snapshot`
* Implement minimal UI states:

    * idle bar
    * loading
    * result card (artifact view)
    * confirmation prompt
* Wire hotkey + window behavior on macOS.

### Targets

* `apps/desktop/src-tauri/src/main.rs`
* `apps/desktop/src-tauri/src/lib.rs`
* `apps/desktop/src-tauri/src/commands.rs`
* `apps/desktop/src-tauri/src/window.rs`
* `apps/desktop/src/` (React UI)

    * `components/CommandBar.tsx`
    * `components/ResultCard.tsx`
    * `components/ConfirmPanel.tsx`
    * `state/`

### Acceptance Criteria

* You can open the bar, submit a command, see result, and confirm destructive actions.
* Recent actions UI shows last N invocations (redacted).

### Definition of Done

* Full v0 flow works on macOS end-to-end with built-ins and stub planner.

### Test Checklist

* Manual smoke checklist:

    * open bar
    * run calculator command
    * show last note
    * delete note requires confirm
    * see recent actions

---

## Milestone 12 — macOS integrations v0 (platform-macos crate)

### Tasks

* Implement macOS adapters for:

    * clipboard read (NSPasteboard)
    * notes storage (v0 could be local file store; EventKit later)
    * global hotkey (Tauri plugin or native)
* Keep API behind traits in core.

### Targets

* `crates/platform-macos/src/lib.rs`
* `crates/platform-macos/src/clipboard.rs`
* `crates/platform-macos/src/hotkeys.rs`
* `crates/platform-macos/src/notes_store.rs` (v0)

### Acceptance Criteria

* Clipboard built-in reads real clipboard on macOS.
* Hotkey toggles command bar.

### Definition of Done

* Platform crate is the only place using macOS-specific APIs.

### Test Checklist

* Manual: copy text → “summarize clipboard” shows it
* Manual: hotkey toggles bar reliably

---

# Appendix — Global Definition of Done for v0

v0 is complete when:

* Core supports: command parsing + routing + planning (stub) + permissions + tool execution + workspace patching.
* Built-ins: Clipboard, Notes, Calculator work end-to-end.
* Event stream logs tool invocations with timing and redaction marker.
* Tauri UI can submit commands, render artifact results, and handle confirmations.
* Extension host can load at least one TS extension and execute its tools.
